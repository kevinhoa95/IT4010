<!doctype html>
<html lang="en">
<head>
    <title>AES (Advanced Encryption Standard) JavaScript implementation in Counter Mode | Movable Type Scripts</title>
    <meta charset="utf-8">
    <meta name="author" content="Chris Veness, www.movable-type.co.uk">
    <meta name="keywords" content="AES advanced encryption algorithm standard counter mode operation javascript">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.3/normalize.min.css">
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.css">
    <!--<link rel="stylesheet" href="../css/base.css">
    <link rel="stylesheet" href="../css/eb-garamond/stylesheet.css">
    <link rel="stylesheet" href="../css/mtl.css">-->
    <style>
        button { font-size: 0.9em; }
        textarea { max-width: 36em; }
        .local-files fieldset { font-size: 80%; width: 45%; }
        .w64 { width: 64em; }
    </style>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/prettify/188.0.0/prettify.js">/* r224/r298 don't work! */</script>
    <script src="http://cdn.rawgit.com/eligrey/FileSaver.js/master/FileSaver.js">/* note cannot run in web worker */</script>
    <!--[if lt IE 9]><script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
    <!--[if le IE 9]><script src="../js/base64.js"></script><![endif]-->
    <script src="mtl.js">/* MTL utils */</script>
    <script src="js/crypto/aes.js">/* AES JavaScript implementation */</script>
    <script src="js/crypto/aes-ctr.js">/* AES Counter Mode implementation */</script>
    <script>
        'use strict';
        $(document).ready(function() {
            // encrypt listener
            $('#encrypt').click( function() {
                var t = new Date();
                var ciphertext = Aes.Ctr.encrypt($('#plaintext').val(), $('#password').val(), 256);
                $('#encrypt-time').html(((new Date() - t))+'ms');
                $('#cipher').val(ciphertext);
            });
            // decrypt listener
            $('#decrypt').click( function() {
                var t = new Date();
                var plain = Aes.Ctr.decrypt($('#cipher').val(), $('#password').val(), 256);
                $('#decrypt-time').html(((new Date() - t))+'ms');
                $('#plain').val(plain);
            });
        });
    </script>
    <script> /* encrypt/decrypt files */
        'use strict';
        $(document).ready(function() {
            $('#src-file').on('change', function() {
                var file = this.files[0];
                $('#progress').removeAttr('value'); // set progress to 'indeterminate' during utf8Encode
                var t1 = new Date();
                var worker = new Worker('aes-ctr-file-webworker.js');
                worker.postMessage({
                    op:       'encrypt',
                    file:     file,
                    password: $('#password-file').val(),
                    bits:     256,
                });
                worker.onmessage = function (msg) {
                    if (msg.data.progress != 'complete') {   // progress notification
                        $('#progress').val(msg.data.progress * 100);                // update progress bar
                    }
                    if (msg.data.progress == 'complete') { // completed
                        $('#progress').val(0);                                      // reset progress bar
                        saveAs(msg.data.ciphertext, file.name+'.encrypted');        // save to file
                        var ciphertext = Aes.Ctr.encrypt('Đôn', $('#password-file').val(), 256);
                        console.log(ciphertext);
                        console.log(msg.data.ciphertext);
                        $('#encrypt-file-time').html(((new Date() - t1)/1000)+'s'); // display time taken
                    }
                }
            });
        });

        $(document).ready(function() {
            $('#enc-file').on('change', function() {
                var file = this.files[0];
                $('#progress').removeAttr('value'); // set progress to 'indeterminate'
                var t1 = new Date();
                var worker = new Worker('aes-ctr-file-webworker.js');
                worker.postMessage({
                    op:       'decrypt',
                    file:     file,
                    password: $('#password-file').val(),
                    bits:     256,
                });
                worker.onmessage = function (msg) {
                    if (msg.data.progress != 'complete') {  // progress notification
                        $('#progress').val(msg.data.progress * 100);                // update progress bar
                    }
                    if (msg.data.progress == 'complete') { // completed
                        $('#progress').val(0);                                      // reset progress bar
                        saveAs(msg.data.plaintext, file.name.replace(/\.encrypted$/,'')+'.decrypted'); // save to file
                        $('#decrypt-file-time').html(((new Date() - t1)/1000)+'s'); // display time taken
                    }
                }
            });
        });
    </script>
    <script>/* test vectors */
        'use strict';
        function byteArrayToHexStr(b) {  // convert byte array to hex string for displaying test vectors
          var s = '';
          for (var i=0; i<b.length; i++) s += b[i]<0x10 ? '0'+b[i].toString(16)+' ' : b[i].toString(16)+' ';
          return s;
        }

        String.prototype.toCodes = function() {
          if (this.length == 0) return '';
          var arr = this.split('');
          for (a in arr) arr[a] = arr[a].charCodeAt(0);
          return arr.join(':');
        }

        function verifyKeyExpansion() {
          var cipher = [0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
                        0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c];
          alert('128: '+keyScheduleToHexStr(Aes.keyExpansion(cipher)));
          var cipher = [0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52,
                        0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5,
                        0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b];
          alert('192: '+keyScheduleToHexStr(Aes.keyExpansion(cipher)));
          var cipher = [0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
                        0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
                        0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
                        0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4];
          alert('256: '+keyScheduleToHexStr(Aes.keyExpansion(cipher)));
        }

        function keyScheduleToHexStr(keySchedule) {  // return expanded key as hex words, as per FIPS-197§A
          var d = '';
          for (var w=0; w<keySchedule.length; w++) {
            for (var b=0; b<4; b++) {
              var byte = keySchedule[w][b];
              d += byte<0x10 ? '0'+byte.toString(16) : byte.toString(16);
            }
            d += ' ';
          }
          return d;
        }
    </script>
    <script> /* show source code */
        'use strict';
        $(document).ready(function() {
            // show source code
            $.get('js/crypto/aes.js', function(data) {
                var src = data.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') // replace &, <, >
                $('#aes-src').html(src);
                prettyPrint();
            }, 'text');
            $.get('js/crypto/aes-ctr.js', function(data) {
                var src = data.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') // replace &, <, >
                $('#aes-ctr-src').html(src);
                prettyPrint();
            }, 'text');
            $.get('aes-ctr-file-webworker.js', function(data) {
                var src = data.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') // replace &, <, >
                $('#aes-ctr-file-webworker-src').html(src);
                prettyPrint();
            }, 'text');
        });
    </script>
</head>

<body>
<header><a href="../"><img src="mtl.gif" alt="Movable Type Home Page"></a>
    <h1>Movable Type Scripts</h1>
    <hr>
    <h2>AES Advanced Encryption Standard</h2>
</header>

<p><b>AES</b> is a ‘symmetric block cipher’ for encrypting texts which can be decrypted with the original
    encryption key.</p>
<p>For many purposes, a simpler encryption algorithm such as <a href="tea-block.html">TEA</a> is perfectly
    adequate – but if you suspect the world’s best cryptographic minds, and a few million dollars of
    computing resource, might be attempting to crack your security, then <a href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>,
    based on the <i>Rijndael</i> algorithm, is the tightest security currently available (approved by
    the US government for classified information up to ‘Secret’ – and in in 192 or 256 key lengths, up
    to ‘Top Secret’). AES was adopted by NIST in 2001 as
    <a href="http://csrc.nist.gov/publications/PubsFIPS.html#197">FIPS-197</a>, and is the replacement for DES which was
    <a href="http://csrc.nist.gov/publications/fips/05-9945-DES-Withdrawl.pdf">withdrawn</a> in 2005.</p>
<p>I developed this JavaScript implementation to to illustrate the original AES standard (NIST
    <a href="http://csrc.nist.gov/publications/PubsFIPS.html#197">FIPS-197</a>)
    as closely as possible. It is intended as an introduction for people seeking to learn something about
    implementing encryption, not an authoritative implementation – cryptography experts will already
    know more than I present here. The emphasis is on transparency and fidelity to the standard rather
    than efficiency.</p>
<p>This script also includes a wrapper function which implements AES in the ‘Counter’
    <a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Counter_.28CTR.29">mode
    of operation</a> (specified in NIST SP <a href="http://csrc.nist.gov/publications/nistpubs/#sp800-38A">800-38A</a>)
    to encrypt arbitrary texts – many descriptions of AES limit themselves to the Cipher routine itself,
    and don’t consider how it can be used to encrypt texts.</p>
<p>This is principally a learning exercise, and I am not a cryptographic expert. I can provide no
    warranty or guarantees if you choose to use this code in production environments.</p>

<form>
    <fieldset><legend>Functional demo</legend>
        <ul>
            <li>
                <label for="password">Password</label>
                <input type="text" name="password" id="password" value="L0ck it up ŝaf3" class="w12">
            </li>
            <li>
                <label for="plaintext">Plaintext</label>
                <textarea name="plaintext" id="plaintext" class="width-full">pssst ... đon’t tell anyøne!</textarea>
            </li>
            <li>
                <label><button type="button" name="encrypt" id="encrypt">Encrypt it</button></label>
                <textarea name="cipher" id="cipher" class="width-full"></textarea>
                <output class="small grey" id="encrypt-time"></output>
            </li>
            <li>
                <label><button type="button" name="decrypt" id="decrypt">Decrypt it</button></label>
                <textarea name="plain" id="plain" readonly class="width-full"></textarea>
                <output class="small grey" id="decrypt-time"></output>
            </li>
        </ul>
    </fieldset>
</form>

<p id="debug">&nbsp;</p>
<p>Much of the Rijndael algorithm is based on arithmetic on a <i><a href="http://en.wikipedia.org/wiki/Finite_field">finite
    field</a></i>, or <i>Galois field</i> (after the mathematician). Regular arithmetic works on
    an infinite range of numbers – keep doubling a number and it will get ever bigger. Arithmetic
    in a finite field is limited to numbers within that field. The Rijndael algorithm works in GF(2<sup>8</sup>),
    in which arithmetic results can always be stored within one byte – which is pretty convenient
    for computers. I can’t begin to understand the <a href="http://en.wikipedia.org/wiki/Finite_field_arithmetic">maths</a> (considering
    that addition and subtraction are the same thing – an <span class="small-caps">xor</span> operation
    – and multiplication is performed ‘modulo an irreducible polynomial’: doubling 0x80 in GF(2<sup>8</sup>)
    gives 0x1b).</p>
<p>The Rijndael algorithm lends itself to widely differing implementations, since the maths can be
    either coded directly, or pre-computed as lookup tables – directly parallel to using log tables for
    arithmetic. Different implementations can have varying pay-offs between speed, complexity, and storage
    requirements. Some may barely resemble each other. In this implementation, I have followed the standard
    closely; as per the standard, I have used a lookup table (‘<a href="http://en.wikipedia.org/wiki/S-box">S-box</a>’)
    to implement the multiplicative inverse (i.e. 1/x) within a finite field (used for the SubBytes transformation),
    but other calculations are made directly rather than being pre-computed.</p>
<p>If you want to convince yourself that the Cipher function is working properly internally (and you
    should!), NIST provide test vectors for AES (appendix C.1 of the standard). Click<br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <button onClick="alert(byteArrayToHexStr(Aes.cipher([0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff],          Aes.keyExpansion([0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f]))))"> 128-bit
    Test Vector </button>
    <button onClick="alert(byteArrayToHexStr(Aes.cipher([0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff],          Aes.keyExpansion([0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f, 0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17]))))"> 192-bit
    Test Vector </button>
    <button onClick="alert(byteArrayToHexStr(Aes.cipher([0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff],          Aes.keyExpansion([0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f, 0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f]))))"> 256-bit
    Test Vector </button>
    <br>
    and the cipher output block should be</p>
<ul>
    <li>128-bit: <i>69 c4 e0 d8 6a 7b 04 30 d8 cd b7 80 70 b4 c5 5a</i> </li>
    <li>192-bit: <i>dd a9 7c a4 86 4c df e0 6e af 70 a0 ec 0d 71 91</i> </li>
    <li>256-bit: <i>8e a2 b7 ca 51 67 45 bf ea fc 49 90 4b 49 60 89</i> </li>
</ul>
<p>(In counter mode, a text could decrypt correctly even if the cipher routine was flawed).</p>
<p>The Inverse Cipher is largely a mirror of the Cipher routine, with parallel functions for Cipher,
    SubBytes and ShiftRows. The MixColumns routine is slightly more complex in the inverse. I have not
    implemented the inverse cipher here as it is not required in counter mode.</p>

<hr>
<p id="counter-mode"><b>Counter mode of operation</b>: the AES standard concerns itself with numeric or binary data (Rijndael,
    along with most other encryption algorithms, works on a fixed-size block of numbers – in the case
    of AES, each block is 128 bits or 16 bytes).</p>
<p>In order to make use of it to encrypt real things (such as texts), it has to be used within a certain
    ‘<a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation">mode of operation</a>’.
    This is the interface between text or files, and the purely numerical encryption algorithm. See NIST
    Special Publication <a href="http://csrc.nist.gov/publications/PubsSPs.html#800-38A">SP800-38A</a> for
    more details and test vectors. </p>
<p>The simplest mode of operation (‘electronic codebook’) encrypts a text block-by-block – but since
    the same block of plaintext will always generate the same block of ciphertext, this can leave too
    many clues for attackers. </p>
<p>In the ‘<a href="http://en.wikipedia.org/wiki/Counter_mode#Counter_.28CTR.29">counter
    mode</a>’ used in this implementation, a counter which changes with each block is first encrypted,
    and the result is bitwise <span class="small-caps">xor</span>’d with the plaintext block to
    get the ciphertext block (so the plaintext is not actually directly encrypted). A unique ‘<a href="http://en.wikipedia.org/wiki/Cryptographic_nonce">nonce</a>’
    is incorporated in the counter to ensure different ciphertexts are always generated from the
    same plaintext every time it is encrypted; this number is stored at the head of the ciphertext
    to enable decryption. A combination of seconds since 1 Jan 1970, a millisecond-timestamp, and
    a sub-millisecond random number gives a very effective nonce. (To resist cryptographic attacks,
    the nonce does not need to be secret or unpredictable, but it is imperative that it is unique).
    In this implementation, the initial block holds the nonce in the first 8 bytes, and the block
    count in the second 8 bytes. Since JavaScript can represent integers up to 2<sup>53</sup>,
    this allows a message size up to 2<sup>57</sup> (c.
    10<sup>17</sup>)
    bytes – unlikely to be a limitation! Note that the nonce in counter mode is the equivalent
    of the  initialisation vector (<a href="http://en.wikipedia.org/wiki/Initialization_vector">IV</a>)
    in other  modes of operation.</p>
<p>A curious quality of counter mode is that decryption also uses the cipher algorithm rather than
    the inverse-cipher algorithm. Though simple to implement, it has been established to be very secure.</p>
<p>Encrypting texts or files require not just the mode of operation. When implementing AES, you have
    to consider</p>
<ul>
    <li>mode of operation; here the Counter (<span class="small-caps">ctr</span>) mode of operation –
        both simple to implement, and very secure</li>
    <li>conversion of text (including multi-byte Unicode texts) to binary/numeric data; here multi-byte
        Unicode characters are converted to <a href="http://en.wikipedia.org/wiki/Utf8">UTF8</a>,
        then the numeric character codes are used to pass to the cipher routine</li>
    <li>conversion of encrypted data to values which can be stored or transmitted without problem; here
        the binary encrypted texts are encoded in <a href="http://en.wikipedia.org/wiki/Base64">Base64</a>,
        which is a very safe 7-bit encoding with no control codes or other troublesome characters.</li>
</ul>
<p>The <b>key</b> in this script is obtained by applying the Cipher routine to encrypt the first
    16/24/32 characters of the password (for 128-/192-/256-bit keys) to make the key. This is a
    convenient way to obtain a secure key within an entirely self-contained script (in a production
    environment, as opposed to this essentially tutorial code, the key might be generated
    as a <a href="sha256.html">hash</a>, e.g. simply <code>key = Sha256(password)</code>).
    In more detail, the supplied password is  converted to to UTF-8 (to be byte-safe),      then
    the first 16/24/32 characters are converted to bytes. The resulting pwBytes is used as a seed
    for the Aes.keyExpansion() which is then used as the key to encrypt pwBytes with Aes.cipher().
    Examples of keys generated in this way from (unrealistically) simple passwords:</p>
<table style="margin-left: 4em">
    <tr>
        <td>‘a’ (U+0061): </td>
        <td class="align-right">pwBytes = </td>
        <td class="code">61 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</td>
    </tr>
    <tr>
        <td> </td>
        <td class="align-right">key =</td>
        <td class="code">60 84 dd 49 14 7b 5d 05 7a e3 f8 81 b9 0e e7 dd</td>
    </tr>
    <tr>
        <td>‘b’ (U+0062): </td>
        <td class="align-right">pwBytes =</td>
        <td class="code">62 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</td>
    </tr>
    <tr>
        <td> </td>
        <td class="align-right">key =</td>
        <td class="code">b4 1a 83 4f da 4b aa 41 76 62 be d6 2c 66 83 6d</td>
    </tr>
    <tr>
        <td>‘☺’ (U+263a):</td>
        <td class="align-right">pwBytes =</td>
        <td class="code">e2 98 ba 00 00 00 00 00 00 00 00 00 00 00 00 00</td>
    </tr>
    <tr>
        <td> </td>
        <td class="align-right">key =</td>
        <td class="code">d1 0c cd fd 44 45 54 ef 59 aa f8 dc 78 8e 9a 7c</td>
    </tr>
</table>
<p>Even with a single bit difference between two passwords (‘a’ and ‘b’), the key is entirely different.</p>
<p>&nbsp;</p>
<p><b>Usage</b>: this implementation would be invoked as follows:</p>
<pre class="prettyprint w48">
  var password = 'L0ck it up saf3';
  var plaintext = 'pssst ... đon’t tell anyøne!';
  var ciphertext = Aes.Ctr.encrypt(plaintext, password, 256);
  var origtext = Aes.Ctr.decrypt(ciphertext, password, 256);
</pre>
<p>Note that there are no standards for data storage formats of AES encryption mode wrapper functions,
    so this is unlikely to inter-operate with standard library functions. It inter-operates between
    client-side JavaScript and Node.js: see
    <a href="https://gist.github.com/chrisveness/b28bd30b2b0c03806b0c">gist.github.com/&#x200b;chrisveness/&#x200b;b28bd30b2b0c03806b0c</a>.
    I have also written a matching <a href="aes-php.html">PHP version</a>.</p>

<hr id="files">

<p>It is also quite simple to encrypt files, by using
    <a href="http://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">web workers</a>,
    <a href="http://developer.mozilla.org/en-US/docs/Web/API/FileReader">FileReader</a> &amp;
    <a href="http://developer.mozilla.org/en-US/docs/Web/API/Blob">Blob</a> objects, and Eli Grey’s
    <code><a href="http://eligrey.com/blog/post/saving-generated-files-on-the-client-side">saveAs()</a></code>:
    <span class="small grey">(not available on IE9-)</span> </p>

<form class="local-files">
    <fieldset>
        <label>Password</label>
        <input type="text" name="password-file" id="password-file" value="L0ck it up ŝaf3">
    </fieldset>
    <fieldset style="float:left;"><legend>Encrypt file</legend>
        <label>Source file</label>
        <input type="file" name="src-file" id="src-file">
        <output class="small grey" id="encrypt-file-time"></output>
        <p>Source file will be encrypted and downloaded with '.encrypted' suffix.</p>
    </fieldset>
    <fieldset><legend>Decrypt file</legend>
        <label>Encrypted file</label>
        <input type="file" name="enc-file" id="enc-file">
        <output class="small grey" id="decrypt-file-time"></output>
        <p>Encrypted file will be decrypted and downloaded with '.decrypted' suffix.</p>
    </fieldset>
    <progress id="progress" value="0" max="100"></progress>
</form>
<p>Note that Aes.Ctr.encrypt expects a string: as binary files may include invalid Unicode sequences
    if treated as strings, I treat the file contents as a byte-stream, converting it to single-byte
    characters before passing it to Aes.Ctr.encrypt.</p>

<hr>

<p id="js"><i>Does it make sense to implement AES in JavaScript?</i> This is really intended as a
    reference implementation to help understand the AES standard, but sometimes JavaScript can be
    used for real-world cryptographic applications (particularly web-based ones). Mostly, a JavaScript
    implementation such as this can provide an easy starting-point for implementation in other languages.
    Though I still think that <a href="tea-block.html">TEA</a> is generally good enough for simple applications,
    and a great deal simpler to use (as well as significantly faster, according to
    <a href="http://jsperf.com/encryption-decryption-comparisons">tests</a> by Tom Doan, thanks Tom).</p>
<p><i>In other languages:</i> I’ve developed a <a href="aes-php.html">PHP version</a> which directly
    mirrors this JavaScript version; it differs in that PHP has Base64 encoding and UTF-8 encoding built-in,
    and has no unsigned-right-shift operator(!), but is otherwise a straightforward port. In other languages,
    be sure to use 64-bit integers/longs, either unsigned or with unsigned right-shift operators; you
    may need to take into consideration the way different languages handle bitwise ops, and of course
    standard issues such as array handling and strict typing. I’m not aware of any other issues. <br>
&nbsp;&nbsp;&nbsp;&nbsp;I’m not familiar with Python, but there is a Python version available at <a href="http://wiki.birth-online.de/snippets/python/aes-rijndael">wiki.birth-online.de/snippets/python/aes-rijndael</a>.</p>
<p><i>Speed:</i> as mentioned, this is not an optimised implementation – using Chrome on a low-to-middling
    2014 machine (Core-i5), this processes around 1MB/sec [still some 100× faster than back in 2008!).</p>
<p>For more information, have a look at</p>
<ul>
    <li>Daemen &amp; Rijnael’s<a href="http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf"> AES
        proposal</a> for Rijndael Block Cipher</li>
    <li><a href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">Wikipedia</a> article</li>
    <!-- <li>Cryptomathic article <a href="http://www.cryptomathic.it/company/aes.html"><i>Do
          We Need AES?</i></a></li> -->
    <li>article from John Savard’s <a href="http://www.quadibloc.com/crypto/co040401.htm">Cryptographic
        Compendium</a></li>
</ul>
<p>For some security applications, a cryptographic hash is more appropriate than encryption – if
    you are interested in a hash function, see my implementations of <a href="sha1.html">SHA-1</a>
    and <a href="sha256.html">SHA-256</a>.</p>
<p><i>October 2009</i>: I have updated the formulation of these scripts to use JavaScript <a href="namespaces.html">namespaces</a> for better
    encapsulation of function names.</p>

<hr class="fullwidth">

<p id="postscript">See below for the source code of the JavaScript implementation,
    also available on <a href="https://github.com/chrisveness/crypto/blob/master/aes.js">GitHub</a>.
    §ection numbers relate the code back to sections in the standard.</p>
<p>With its untyped C-style syntax, JavaScript reads remarkably close to pseudo-code: exposing the
    algorithms with a minimum of syntactic distractions. These functions should be simple to
    translate into other languages if required, though can also be used as-is in browsers and Node.js.</p>
<p>For convenience &amp; clarity, I have extended the base JavaScript String object with utf8Encode(),
    utf8Decode(), base64Encode(), base64Decode() methods: I don’t see great likelihood of conflicts.</p>
<p id="licence"><a href="https://tldrlegal.com/license/mit-license" class="float-right"><img src="license-osi-mit.png" alt="OSI MIT License"></a>
    I offer these scripts for free use and adaptation to balance my debt to the open-source info-verse.
    You are welcome to re-use these scripts [under an <a href="https://tldrlegal.com/license/mit-license">MIT</a> licence,
    without any warranty express or implied] provided solely that you retain my copyright notice and a link to this page.</p>
<p><a target="_blank" href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=3737803" style="float: right;"><img alt="Paypal donation" style="margin: 4px;" src="https://www.paypal.com/en_GB/i/btn/btn_donate_SM.gif"></a>
    If you would like to show your appreciation and support continued development of these scripts, I would most gratefully accept
    <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=3737803" title="Thank you!">donations</a>.</p>
<p>If you have any queries or find any problems, contact me at <span class="rtl">ku.oc.epyt-elbavom@cne-stpircs</span>.</p>
<p><span class="note"><i>© 2005-2016 Chris Veness</i></span> </p>

<hr class="fullwidth">
<pre class="fullwidth prettyprint lang-js" id="aes-src"></pre>

<hr class="fullwidth">
<pre class="fullwidth prettyprint lang-js" id="aes-ctr-src"></pre>

<hr class="fullwidth">
<pre class="fullwidth prettyprint lang-js" id="aes-ctr-file-webworker-src"></pre>

<!--[if lte IE 8]> <p>If IE8-, gets confused about line endings, you can view source at
    <a href="https://github.com/chrisveness/crypto/blob/master/aes.js">GitHub</a></p> <![endif]-->

</body>
</html>
